# Ticket Block Project

# Abstract

The Ethereum blockchain is starting to become more utilised compared to recent years. Especially with its recent system upgrade known as the merge which cuts down its high energy usage. Nowadays, the most popular type of applications is centralised based applications. Dynamically generated data either gets written to a non-relational database or a relational one that stores data within tables. However, there is a difference between decentralised and centralised applications. In decentralised systems, every single transaction gets placed into the blockchain which is a publicly accessible distributed ledger. Anybody in the world has access to the blockchain database. Its immutability nature renders its data highly secure and reliable. Nowadays, as there are more and more events being organised and hosted by individuals, there are a couple of critical problems that we face. One of them being event tickets being tampered and the second one being replicated and counterfeited versions.

This priject analyses and evaluates the implementation of a basic marketplace used to prevent fake event tickets being resold. Non-fungible tokens are used for this. At the same time conveying how useful these tokens can be for proof of ownership using complex blockchain technologies. Throughout the development of the marketplace which aims to solve the above-mentioned problems, it has been found by observing the code outputs that once a non-fungible token is minted on the blockchain through a smart contract written in solidity, every single transaction is timestamped and recorded sequentially. Hence, copies of them cannot be made. Transaction data can be viewed inside the logs of every meta mask wallet account that is connected to the application. Thus, switching between accounts always shows different transactions that have been processed at various times. For example, when a token was minted, listed on sale, or purchased. Finally, it has also been found that the same token cannot be purchased twice because a unique ID for every token is generated and incremented every time a token is minted. Disallowing the same token from being bought a second time.

# Introduction

Nowadays blockchain-oriented decentralized applications are starting to become more and more popular. These types of applications are adversaries to the typical centralised ones due to its strong tamper-proof, immutability and secure nature. The most widely recognized and heavily used blockchain is Ethereum. In addition to the aforementioned, a serious issue that we come across daily are expensive premium event tickets being tampered and resold on malicious websites by individuals who might create fake tickets. Purposefully counterfeiting them from the original owners to prevent paying for the original ticket to attend an event. Therefore, to overcome this problem, the paper focuses on addressing how we can take advantage of non-fungible tokens to allow ticket buyers to prove that they are the ones who purchased a specific ticket. Eliminating any malicious activity. Disallowing individuals from gaining access to different classes of tickets where they range in price which can cost a lot of money. Furthermore, the proposed web application that is to be developed does not support debit or credit card payments for purchasing event tickets. On the one hand, mainly due to security reasons. On the other hand, the fact that governed authorities such as banks are generally involved to verify the authenticity of transactions. Hence, this can take a very long time and can potentially fail if malicious activity is detected. Instead, to bypass the problem of transaction approval delays, the proposed marketplace system that is going be developed supports smart contract functionality that executes on the blockchain ledger instead.

Smart Contracts that reside on the blockchain are lines of code that are compiled into bytecode which run under certain preconditions that must be met. They are also bulletproof in terms of security since smart contracts make use of asymmetric key cryptography. We take such a public key to encrypt the contents of a token by applying 256-bit encryption which makes it impossible for anyone to tamper with the data as it converts the plaintext data into ciphertext. Rendering the data unreadable and thereby cannot be intercepted. A private key is also required to decrypt its contents. Hence, the proposed system implements a smart contract which executes separately from the system’s backend. Preventing event tickets from being counterfeited by allowing end-users to interact with these contracts that transfers ownership of a token that uniquely identifies an event ticket. Finally, the upcoming sections of this paper are split into the following - Section II of this paper addresses the related work within this field. Section III outlines the implementation approaches of the system. Section IV presents the results produced by the system. Finally, Section V concludes the paper.

# Related Work

Throughout this section of the paper, we explore the relevant work and research that other authors have conducted regarding decentralized systems. The various use cases and advantages are also evaluated based on research. In addition to the previous section, the problem of expensive event tickets being counterfeited and tampered with has been outlined. Thus, this can be circumvented by implementing a non-fungible token marketplace. Relying on smart contract functionality to deliver a proof of ownership solution. Preventing event tickets from being counterfeited. Non-fungible tokens are unique identifiers for rare artwork, game collections or event entertainment tickets that live inside small blocks of data within the blockchain. Commonly known as the memory pool of transactions. According to [1], the authors convey that there are also other variations of tokens available such as fungible and semi fungible. Fungible tokens contain different characteristics and use cases compared to non-fungible ones. These types of tokens can usually be duplicated for other ones that are dissimilar to each other. Therefore, eliminating any form of proof of ownership unlike non-fungible tokens. Which is a big advantage of using NFTs in lieu of fungible tokens. The next section evaluates how the tokens are registered on the blockchain taking into consideration some disadvantages that can be present when minting new tokens. 

According to [2], the authors discuss how these types of tokens can be created by implementing a method of inserting a new token inside the blockchain. Known as minting. This is the process of registering a token whereby any individual can view the contents of the token such as its ID, name, and price. But cannot alter the data because it is immutable. Usually there are gas fees that are associated which is a disadvantage. After the minting process is completed, a transaction is created and added inside the ledger with an associating nonce value that represents the current transaction number that has been processed. Thus, the proposed system is going to support the process of minting, buying, and selling tokens. However, there is a small disadvantage that comes with this. Every transaction generated for minting a token can potentially fail but is very unlikely. A syntax or runtime error within the smart contract can potentially corrupt a transaction and render it invalid. According to [3], the authors convey how transactions are deemed to be costly in terms of price. Every transaction executed on the blockchain typically incurs a fee known as gas. This fee compensates for the GPU power that a machine consumes to solve a complicated mathematical puzzle to verify and approve a transaction from within a temporary location called the memory pool. The more gas that is paid, the faster it gets validated from the memory pool of pending transactions. Also, according to the research performed by [3], various optimization techniques are outlined which aids in the reduction of gas fees which is important in developing a reliable and fast application. Moreover, the next section evaluates a couple of optimization techniques that can be applied inside smart contracts to significantly reduce the gas fees. And, how they can be interfaced with by the frontend of applications to communicate with function declarations to buy, sell, list and transfer ownership of tokens.

According to [4], the authors of the paper mention that smart contracts are capable of handling externally owned accounts (EOAs). These are independent accounts that are unique to a single individual. Each account has an associated private key that must never be shared. Tokens that are bought by that specific account is only available to that user and no other account. Unless ownership is transferred again to a different account. In other words, the new person who purchases the previously bought token becomes the new owner of the token. Users can also view all the transactions the account has made, however, only if the owner of the account decides to transfer ownership of the token to a different account, then a new transaction regarding that purchase is recorded. Figure 1.0 below represents how we can switch between accounts using a piece of software called Meta Mask. Similarly, according to [5], the authors explain how communication with smart contracts can be rendered possible through a JavaScript library called Web3.js. Also, ganache is a popular testing blockchain environment that can be used alongside Web3 APIs to view account balances and the transactions recorded inside the blockchain in real-time. The more transactions that are recorded, the higher the amount of gas fees that are accumulated. To bypass this, the authors in [3] mention that one way to gradually reduce the fees is to store integer variables with less bytes. The results show that on average using 8 bytes of unsigned integer data reduces the gas fees by “18%” compared to integer sizes of 256 bytes.

According to [4], the authors of the paper mention that smart contracts are capable of handling externally owned accounts (EOAs). These are independent accounts that are unique to a single individual. Each account has an associated private key that must never be shared. Tokens that are bought by that specific account is only available to that user and no other account. Unless ownership is transferred again to a different account. In other words, the new person who purchases the previously bought token becomes the new owner of the token. Users can also view all the transactions the account has made, however, only if the owner of the account decides to transfer ownership of the token to a different account, then a new transaction regarding that purchase is recorded. Figure 1.0 below represents how we can switch between accounts using a piece of software called Meta Mask. Similarly, according to [5], the authors explain how communication with smart contracts can be rendered possible through a JavaScript library called Web3.js. Also, ganache is a popular testing blockchain environment that can be used alongside Web3 APIs to view account balances and the transactions recorded inside the blockchain in real-time. The more transactions that are recorded, the higher the amount of gas fees that are accumulated. To bypass this, the authors in [3] mention that one way to gradually reduce the fees is to store integer variables with less bytes. The results show that on average using 8 bytes of unsigned integer data reduces the gas fees by “18%” compared to integer sizes of 256 bytes.

## Figure 1.0 - Externally Owned Meta Mask Accounts

<img width="500" height = "500" alt="image" src="https://user-images.githubusercontent.com/29733613/203999537-e05c49a5-a0a5-4d20-82ca-c19c0419a779.png">

After the smart contract for creating and buying tokens are completed, we can then interact with the compiled contract through a Web3 API called “ethers”. This package is available to install using the node package manager (NPM). The API can be used in React JS to perform several operations with the smart contracts that have been compiled and migrated. A JSON file can be produced after migrating the contract which is then imported into another file which deals with the Context API. For example, fetching the contract data and its associating methods once compiled into bytecode. By default, every account on the blockchain is given a default balance of 100 ETH to use for development purposes. Also, during the development of decentralized applications, truffle can be used as a testing environment for the development of the smart contract and ganache as the local blockchain environment.

The authors in [6] discuss in their paper about the implementation of an e-Voting system to prevent fake and fraudulent votes for electronic campaigns in India. Very similar to the current problem that is being investigated regarding event tickets. The problem that they are facing are physical votes on paper being copied by other voters in a polling place. And placing votes for a wrong candidate by mistake. Thereby the votes cannot be placed a second time, hence rendering the vote invalid. Thus, they are focusing on developing a web application that allows individuals to place votes from anywhere in the world through a smart contract to prevent physical votes from being falsely casted. By doing this, the voters can place their vote by moving their token that uniquely represents a vote to the candidate’s wallet to prevent such problem.

In [7] the author analyses an advantage of using non-fungible tokens. Every token registered is associated with a unique signature in the form of a 20-byte hexadecimal hash that is currently in circulation. Linked to the person who owns the token. Therefore, this way the tokens can easily be tracked. However, on the other hand, the same author outlines one caveat that NFTs face. Intellectual Property Rights can cause an issue. Mainly because there have been instances where individuals have reproduced an authentic token that has already been minted by taking a photo of its meta data which does not fully give way to full proof of ownership. There are uncertainties as to whether the token has been bought belongs to the owner or not. Also, another caveat that the author evaluates is the environmental impact of minting tokens. Based on the studies in [7], it has been estimated that “Ethereum consumes approximately 44.94 Terra-Wat hours of electricity every year which is almost as much as the total electricity consumption of Qatar and Hungary combined in a single year. 

# Solution Implementation

When regular users are accessing the application, by default they should not have access to all the NFTs that are available to mint on the Ethereum network. The application supports a fully-fledged authentication system whereby users must register an account, verify their e-mail and login before viewing available tokens for sale. Figures 1.1 and 1.2 below shows the user interface for registering and verifying the e-mail address. Furthermore, after the authentication process is complete, users can proceed to the section where they can mint an NFT on the blockchain. As previously mentioned, minting a token refers to creating an instance of a transaction on the blockchain for a specific token. This elevates the notion of proof of ownership. Also, whenever a user decides to change accounts using meta mask, the creator address is always stored in an object that is unique from the other accounts. Figures 1.3 and 1.4 shows the form for minting a token and the output that it produces which is vital in proving that the owner of the token is authentic in the form of JSON data.

## Figure 1.1 - Register User Account Interface

Figure shows the user interface for registering a new account on the application

<img width="600" height = "350" alt="image" src="https://user-images.githubusercontent.com/29733613/203999834-6d6ee3b0-0474-43cb-b3f1-ade5e292d7ed.png">

When regular users are accessing the application, by default they should not have access to all the NFTs that are available to mint on the Ethereum network. The application supports a fully-fledged authentication system whereby users must register an account, verify their e-mail and login before viewing available tokens for sale. Figures 1.1 and 1.2 below shows the user interface for registering and verifying the e-mail address. Furthermore, after the authentication process is complete, users can proceed to the section where they can mint an NFT on the blockchain. As previously mentioned, minting a token refers to creating an instance of a transaction on the blockchain for a specific token. This elevates the notion of proof of ownership. Also, whenever a user decides to change accounts using meta mask, the creator address is always stored in an object that is unique from the other accounts. Figures 1.3 and 1.4 shows the form for minting a token and the output that it produces which is vital in proving that the owner of the token is authentic in the form of JSON data.

## Figure 1.2 – Verify E-mail Address User Interface

Figure shows the user interface for verifying the e-mail address used to register

<img width="600" height = "370" alt="image" src="https://user-images.githubusercontent.com/29733613/204000060-8a1e0330-317f-4677-9e3d-f17ba12c4ee6.png">


The output that is produced when an authenticated user mints their desired token is a unique transaction hash. It is associated with the newly generated token ID that has been created which increments every time within the smart contract to prevent the same ID from being used over again. This receipt is very important for proving that the currently logged in user is the one who minted the token and not somebody else. Mainly because the hash belongs to the individual minted token. Therefore, it cannot be replicated. In addition to the mentioned above, global state management is also used as a secondary solution for dealing with the problem being investigated, known as the Context API in React JS. For this application, global state variable management is used which involves connecting the user’s meta mask wallet, fetching available token data, minting a token, and purchasing it. One reason why the Context API is used over local state management is because functions and global variables can be declared within a file named Web3 Context and therefore can be accessed anywhere within the application by instantiating and globally exporting a provider that takes in the defined variables and functions. Also, a custom hook is created out of the context which is wrapped around the main index file that gives access to these functions globally. Also, figure 1.2.1 below shows the authentication and NFT services both running in parallel allowing users to send HTTP requests to the docker containers through two open ports.

Initially the application is split up into two parts, the backend and frontend. Within the backend, the microservices architecture is used to run the authentication and NFT service through composed docker containers. An advantage of applying this architecture is its high level of fault tolerance. Assume one service collapses such as the authentication service, then the rest of the application is not affected if only one service goes down. Once the user authenticates, they can mint a token which also at the same time sends a POST request to the backend server. Whereby it writes the data regarding a token to the database schema and ultimately the server responds back with a status code of 201. Indicating that a new resource has been created. In addition to the microservices architecture, the client / server architecture is also used. Establishing a TCP connection to the server. Allowing clients to send requests such as viewing all the available tokens by sending a GET request or removing all available tokens by sending a DELETE request. This has been accomplished by implementing a middleware function within the main development server that enables the cross-origin resource sharing (CORS) policy. The policy allows the client to communicate with the backend services without the frontend throwing an error.

## Figure 1.2.1 – Docker Running Microservices

Figure shows the backend microservices running in parallel through docker containers

<img width="500" height = "360" alt="image" src="https://user-images.githubusercontent.com/29733613/204000388-3d24d768-5655-44df-bec4-2a1e2ba955dc.png">

## Figure 1.3 – Mint Non-Fungible Token UI

Figure shows the form for inserting a new token into circulation on the blockchain

<img width="600" height = "360" alt="image" src="https://user-images.githubusercontent.com/29733613/204000546-8ef3323a-99ed-405f-a319-f805ff8411d2.png">

## Figure 1.4 – Minted Token Output

Figure shows the JSON data returned by the smart contract after minting a token

<img width="600" height = "360" alt="image" src="https://user-images.githubusercontent.com/29733613/204000695-28e6f7b3-9f7f-4dea-a43f-523eb967ab9d.png">

# Implementation Results

The initial work that has been set out has successfully been met up to a certain extent. There are a couple of small issues with the smart contract code. Firstly, when ownership of a token is transferred from one account to another, the creator of the token does not receive the ether payment. A significant amount of time was spent troubleshooting the root cause of the problem, but it could be identified. Secondly, when a token is purchased, the transaction does not record the price of the token that has to be paid. Which for this application is not really that important, however if the application were to be pushed into production, then these issues would be looked over in more depth. Nevertheless, the required functionality such as listing a token for sale and purchasing it has been implemented successfully. When it is minted on the blockchain it sends the data to the database and whenever the user views all the available tokens for sale a GET request is sent which allows the server to retrieve all available tokens for sale, returning a 200 OK status code indicating that the request has been successful. Figure 1.6 below shows the result of listing all the tokens for sale. Furthermore, the function for buying a token is invoked from the smart contract gives back the newly created token ID and after the user decides to buy the token, a meta mask window modal appears that displays the data regarding the transaction. 

Figure 1.7 below displays the results of interacting with the contract. It clearly shows how the buy token function is being invoked. The transaction also displays the amount of gas that needs to be paid. As mentioned previously in the paper, the implementation makes use of 8 bytes of data to store the token data which reduced the total amount of gas to be paid. Furthermore, immediately after the token is purchased by a different account than the creator of the token, the creator field no longer displays who minted the token, but the new owner of the token. Local storage is used to store the new owner in the browsers storage so it can display the parsed data back to the screen. And when the token is bought, the page is reloaded which then displays the owner field in lieu of the creator with a tag that identifies that the token has been purchased. When a token is purchased, the buy NFT button is made disabled which means it cannot be purchased again. Figure 1.8 shows the new owner of the token being displayed on the screen. Finally, in Figure 1.9 we can see the receipt that has been generated for the account that bought the token, this way we can keep track of all the tokens that are being purchased and sold.

## Figure 1.6 – Tokens Available for Sale

Figure shows a minted token being displayed for sale which can be bought

<img width="620" height = "380" alt="image" src="https://user-images.githubusercontent.com/29733613/204000889-74d43d55-2047-4f78-8299-9cc5d9ed65b0.png">

## Figure 1.7 – Meta Mask Buy Token Event

Figure shows the meta mask interface when we invoke the buy NFT function

<img width="600" height = "370" alt="image" src="https://user-images.githubusercontent.com/29733613/204001142-9b6982fb-1fe0-4d8e-9a36-602316c77709.png">

## Figure 1.8 – New NFT Owner

Figure shows the result when the NFT is purchased. The creator field is changed to the new owner.

<img width="620" height = "380" alt="image" src="https://user-images.githubusercontent.com/29733613/204001268-84126780-6f10-471f-aa27-3ac8a90c4a7b.png">

## Figure 1.9 – Buy NFT Transaction Receipt

Figure shows the receipt generated after the token is bought

<img width="620" height = "380" alt="image" src="https://user-images.githubusercontent.com/29733613/204001416-08601c9d-f23c-4cb0-b014-b46605cc9f75.png">

# Project Conclusion

Overall, non-fungible tokens are very useful in preventing real-world problems such as assets being counterfeited by individuals. These types of tokens are preferred over semi-fungible and fungible tokens because their meta data cannot be mutated. The application of NFTs to the application that has been built was successful in preventing fake event tickets from being copied and replicated by other users. By developing the backend business logic separately from the frontend, we were able to implement two different services that perform different tasks independently from each other. Both authentication and NFT services were capable of consuming RESTful APIs that allows the frontend to communicate with and consume. Furthermore, the authentication service allowed the users to register a new account and verify it before logging in. This was very important because generally we should not allow any random user minting tokens without being authenticated first. Also, after a significant amount of time that has been spent on learning solidity to implement the functionality for the NFT smart contract, the important functions for selling and purchasing tokens(s) was implemented successfully without any issues. Nevertheless, as there were a couple of problems with transferring ether to the creator of the token, we were able to make use of the buy and sell functions effectively using the Web3 React API without any critical errors being thrown that would hinder the web application. The next section outlines one important feature that is taken into consideration regarding future work.

In addition to the previous section, as there is a tight one-month deadline for the application, there were a couple of additional features that were planned out to be developed should the deadline be longer. A Dutch Auction system would be integrated into the existing application as future work which would be implemented as a smart contract which would then be utilised throughout the frontend using React components. Initially there would be an extremely high listing price for the token and gradually over a span of 10 minutes the price would decrease significantly. Until an individual places a bid that is slightly above the current value of the token. An advantage of using this kind of bidding system compared to First Priced Sealed Bid is that it prevents multiple bids from being placed at a single time. Thus, as soon as a bid is casted by an individual, the auction ends. However, a disadvantage of applying this method of bidding is that this method can place emotional stress upon the individuals that are participating in the bidding session due to uncertainty of the bid placed.

# References

[1] F.Khan, R.Kothari, M.Patel and N.Banoth. “Enhancing Non-Fungible Tokens For the Evolution of Blockchain Technology”, 2022 IEEE Proceedings of the International Conference on Sustainable Computing and Data Communication Systems, pp. 1148-1152

[2] H.R.Hasan, K.Salah, A.Battah, M.Madine, I.Yaqoob, R. Jayaraman, M.Omar, “Incorporating Registration, Reputation, and Incentivization Into the NFT Ecosystem”, 2022 RCII-2019-002–Center for Digital Supply Chain and Operations Management. pp. 76416-76433

[3] N.Masla, V.Vyas, J.Gautam, R.N.Shaw, A.Ghosh, “Reduction in Gas Cost for Blockchain Enabled Smart Contract”, 2021, IEEE 4th International Conference on Computing, Power and Communication Technologies (GUCON). Pp 1-6.

[4] B.K, Mohanta, S.S, Panda, D. Jena, “An Overview of Smart Contract and Use cases in Blockchain Technology”. 2018, IEEE 9th ICCCNT 2018, Pp 1-4.

[5] D.Zinca, V.A, Negrean, “Development of a Road Tax Payment Application using the Ethereum Platform”, 2018, IEEE, pp. 1-4.

[6] S.Drakshayani, U.Vijayalakshmi, S.Rupa Sri, A.Srivani, A.Vyshnavi, “Online Voting System Using Blockchain”, 2022, IEEE Proceedings of the International Conference on Electronics and Renewable Systems, pp 1-6

[7] W. Rehman, H.Zainab, J.Imran, N, Zakaria, “NFTs Applications And Challenges”, 2021 IEEE Paper, pp. 1-7

Dutch Auction: https://www.masterclass.com/articles/dutch-auction
